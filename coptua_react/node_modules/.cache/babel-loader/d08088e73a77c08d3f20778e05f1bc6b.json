{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nexport const resolveFetch = customFetch => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === 'undefined') {\n    _fetch = (...args) => import('@supabase/node-fetch').then(({\n      default: fetch\n    }) => fetch(...args));\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\nexport const resolveResponse = () => __awaiter(void 0, void 0, void 0, function* () {\n  if (typeof Response === 'undefined') {\n    // @ts-ignore\n    return (yield import('@supabase/node-fetch')).Response;\n  }\n  return Response;\n});\nexport const recursiveToCamel = item => {\n  if (Array.isArray(item)) {\n    return item.map(el => recursiveToCamel(el));\n  } else if (typeof item === 'function' || item !== Object(item)) {\n    return item;\n  }\n  const result = {};\n  Object.entries(item).forEach(([key, value]) => {\n    const newKey = key.replace(/([-_][a-z])/gi, c => c.toUpperCase().replace(/[-_]/g, ''));\n    result[newKey] = recursiveToCamel(value);\n  });\n  return result;\n};\n/**\n * Determine if input is a plain object\n * An object is plain if it's created by either {}, new Object(), or Object.create(null)\n * source: https://github.com/sindresorhus/is-plain-obj\n */\nexport const isPlainObject = value => {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};","map":{"version":3,"sources":["../../../src/lib/helpers.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,OAAO,MAAM,YAAY,GAAI,WAAmB,IAAW;EACzD,IAAI,MAAa;EACjB,IAAI,WAAW,EAAE;IACf,MAAM,GAAG,WAAW;GACrB,MAAM,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;IACvC,MAAM,GAAG,CAAC,GAAG,IAAI,KACf,MAAM,CAAC,sBAA6B,CAAC,CAAC,IAAI,CAAC,CAAC;MAAE,OAAO,EAAE;IAAK,CAAE,KAAK,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;GACrF,MAAM;IACL,MAAM,GAAG,KAAK;EACf;EACD,OAAO,CAAC,GAAG,IAAI,KAAK,MAAM,CAAC,GAAG,IAAI,CAAC;AACrC,CAAC;AAED,OAAO,MAAM,eAAe,GAAG,CAAA,KAAqC,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;EAClE,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE;IACnC;IACA,OAAO,CAAC,MAAM,MAAM,CAAC,sBAA6B,CAAC,EAAE,QAAQ;EAC9D;EAED,OAAO,QAAQ;AACjB,CAAC,CAAA;AAED,OAAO,MAAM,gBAAgB,GAAI,IAAyB,IAAa;EACrE,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;IACvB,OAAO,IAAI,CAAC,GAAG,CAAE,EAAE,IAAK,gBAAgB,CAAC,EAAE,CAAC,CAAC;GAC9C,MAAM,IAAI,OAAO,IAAI,KAAK,UAAU,IAAI,IAAI,KAAK,MAAM,CAAC,IAAI,CAAC,EAAE;IAC9D,OAAO,IAAI;EACZ;EAED,MAAM,MAAM,GAAwB,CAAA,CAAE;EACtC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,KAAI;IAC5C,MAAM,MAAM,GAAG,GAAG,CAAC,OAAO,CAAC,eAAe,EAAG,CAAC,IAAK,CAAC,CAAC,WAAW,CAAA,CAAE,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;IACxF,MAAM,CAAC,MAAM,CAAC,GAAG,gBAAgB,CAAC,KAAK,CAAC;EAC1C,CAAC,CAAC;EAEF,OAAO,MAAM;AACf,CAAC;AAED;;;;AAIG;AACH,OAAO,MAAM,aAAa,GAAI,KAAa,IAAa;EACtD,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,EAAE;IAC/C,OAAO,KAAK;EACb;EAED,MAAM,SAAS,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC;EAC9C,OACE,CAAC,SAAS,KAAK,IAAI,IACjB,SAAS,KAAK,MAAM,CAAC,SAAS,IAC9B,MAAM,CAAC,cAAc,CAAC,SAAS,CAAC,KAAK,IAAI,KAC3C,EAAE,MAAM,CAAC,WAAW,IAAI,KAAK,CAAC,IAC9B,EAAE,MAAM,CAAC,QAAQ,IAAI,KAAK,CAAC;AAE/B,CAAC","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => import('@supabase/node-fetch').then(({ default: fetch }) => fetch(...args));\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nexport const resolveResponse = () => __awaiter(void 0, void 0, void 0, function* () {\n    if (typeof Response === 'undefined') {\n        // @ts-ignore\n        return (yield import('@supabase/node-fetch')).Response;\n    }\n    return Response;\n});\nexport const recursiveToCamel = (item) => {\n    if (Array.isArray(item)) {\n        return item.map((el) => recursiveToCamel(el));\n    }\n    else if (typeof item === 'function' || item !== Object(item)) {\n        return item;\n    }\n    const result = {};\n    Object.entries(item).forEach(([key, value]) => {\n        const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ''));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n/**\n * Determine if input is a plain object\n * An object is plain if it's created by either {}, new Object(), or Object.create(null)\n * source: https://github.com/sindresorhus/is-plain-obj\n */\nexport const isPlainObject = (value) => {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return ((prototype === null ||\n        prototype === Object.prototype ||\n        Object.getPrototypeOf(prototype) === null) &&\n        !(Symbol.toStringTag in value) &&\n        !(Symbol.iterator in value));\n};\n//# sourceMappingURL=helpers.js.map"]},"metadata":{},"sourceType":"module"}