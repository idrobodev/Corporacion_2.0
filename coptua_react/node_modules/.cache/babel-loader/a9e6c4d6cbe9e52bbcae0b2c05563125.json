{"ast":null,"code":"import { apiService, ROLES, apiClient } from './apiService';\nimport { dbService } from './databaseService';\nclass StorageService {\n  async isAdmin() {\n    return await dbService.hasPermission(ROLES.ADMINISTRADOR);\n  }\n  async upload(file, path = '') {\n    if (!(await this.isAdmin())) {\n      throw new Error('Permission denied: Admin access required');\n    }\n    if (file.size > 10 * 1024 * 1024) {\n      throw new Error('File size exceeds 10MB limit');\n    }\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      formData.append('path', path || '');\n      const response = await apiClient.post('/files/upload', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      });\n      return {\n        path: response.data.path,\n        publicUrl: response.data.url\n      };\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('Error uploading file:', error);\n      throw new Error(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || 'Error al subir archivo');\n    }\n  }\n  async deleteFile(fullPath) {\n    if (!(await this.isAdmin())) {\n      throw new Error('Permission denied: Admin access required');\n    }\n    const {\n      error\n    } = await supabase.storage.from('documents').remove([fullPath]);\n    if (error) throw error;\n\n    // Eliminar metadatos en tabla 'archivos' si existe\n    try {\n      await supabase.from('archivos').delete().eq('ruta', fullPath);\n    } catch (e) {\n      console.warn('No se pudo eliminar metadatos de tabla \"archivos\" (puede no existir):', e === null || e === void 0 ? void 0 : e.message);\n    }\n  }\n  async listFiles(path = '') {\n    const {\n      data,\n      error\n    } = await supabase.storage.from('documents').list(path, {\n      limit: 100,\n      sortBy: {\n        column: 'name',\n        order: 'asc'\n      }\n    });\n    if (error) throw error;\n\n    // Filter files and folders (folders end with /)\n    let files = data.filter(item => !item.name.endsWith('/'));\n    const folders = data.filter(item => item.name.endsWith('/')).map(item => item.name.slice(0, -1)); // Remove trailing /\n\n    // Filter out placeholder files\n    files = files.filter(item => item.name !== '_placeholder');\n    return {\n      files,\n      folders\n    };\n  }\n  async deleteFolder(path) {\n    if (!(await this.isAdmin())) {\n      throw new Error('Permission denied: Admin access required');\n    }\n\n    // Get all contents recursively\n    const {\n      data: items,\n      error: listError\n    } = await supabase.storage.from('documents').list(path, {\n      recursive: true\n    });\n    if (listError) throw listError;\n    if (items.length === 0) return; // Empty folder\n\n    // Build full paths to delete\n    const pathsToDelete = items.map(item => `${path}/${item.name}`);\n    const {\n      error\n    } = await supabase.storage.from('documents').remove(pathsToDelete);\n    if (error) throw error;\n  }\n  async createFolder(folderName, parentPath = '') {\n    if (!(await this.isAdmin())) {\n      throw new Error('Permission denied: Admin access required');\n    }\n    const fullPath = parentPath ? `${parentPath}/${folderName}` : folderName;\n    // Create folder by uploading a hidden placeholder file\n    const emptyBlob = new Blob([''], {\n      type: 'application/json'\n    });\n    const {\n      data,\n      error\n    } = await supabase.storage.from('documents').upload(`${fullPath}/_placeholder`, emptyBlob);\n    if (error) throw error;\n    return data;\n  }\n  async renameFolder(oldName, newName, parentPath = '') {\n    if (!(await this.isAdmin())) {\n      throw new Error('Permission denied: Admin access required');\n    }\n    const oldPath = parentPath ? `${parentPath}/${oldName}` : oldName;\n    const newPath = parentPath ? `${parentPath}/${newName}` : newName;\n\n    // List contents recursively\n    const {\n      data: items,\n      error: listError\n    } = await supabase.storage.from('documents').list(oldPath, {\n      recursive: true\n    });\n    if (listError) throw listError;\n\n    // Move each item\n    for (const item of items) {\n      const oldFullPath = `${oldPath}/${item.name}`;\n      const newFullPath = oldFullPath.replace(oldPath, newPath);\n      const {\n        error: moveError\n      } = await supabase.storage.from('documents').move(oldFullPath, newFullPath);\n      if (moveError) {\n        // Rollback on error (simplified; in production, use transactions)\n        console.error('Rename failed for item:', item.name, moveError);\n        throw moveError;\n      }\n    }\n\n    // Delete placeholder if exists\n    await this.deleteFile(`${oldPath}/_placeholder`).catch(() => {}); // Ignore if not exists\n  }\n  async getDownloadUrl(path) {\n    const {\n      data,\n      error\n    } = await supabase.storage.from('documents').getPublicUrl(path);\n    if (error) throw error;\n    return data.publicUrl;\n  }\n}\nexport const storageService = new StorageService();\nexport default storageService;","map":{"version":3,"names":["apiService","ROLES","apiClient","dbService","StorageService","isAdmin","hasPermission","ADMINISTRADOR","upload","file","path","Error","size","formData","FormData","append","response","post","headers","data","publicUrl","url","error","_error$response","_error$response$data","console","message","deleteFile","fullPath","supabase","storage","from","remove","delete","eq","e","warn","listFiles","list","limit","sortBy","column","order","files","filter","item","name","endsWith","folders","map","slice","deleteFolder","items","listError","recursive","length","pathsToDelete","createFolder","folderName","parentPath","emptyBlob","Blob","type","renameFolder","oldName","newName","oldPath","newPath","oldFullPath","newFullPath","replace","moveError","move","catch","getDownloadUrl","getPublicUrl","storageService"],"sources":["/Users/todoporunalma/Desktop/coptua_react/src/services/storageService.js"],"sourcesContent":["import { apiService, ROLES, apiClient } from './apiService';\nimport { dbService } from './databaseService';\n\nclass StorageService {\n  async isAdmin() {\n    return await dbService.hasPermission(ROLES.ADMINISTRADOR);\n  }\n\n  async upload(file, path = '') {\n    if (!(await this.isAdmin())) {\n      throw new Error('Permission denied: Admin access required');\n    }\n\n    if (file.size > 10 * 1024 * 1024) {\n      throw new Error('File size exceeds 10MB limit');\n    }\n\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      formData.append('path', path || '');\n\n      const response = await apiClient.post('/files/upload', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n        },\n      });\n\n      return {\n        path: response.data.path,\n        publicUrl: response.data.url\n      };\n    } catch (error) {\n      console.error('Error uploading file:', error);\n      throw new Error(error.response?.data?.message || 'Error al subir archivo');\n    }\n  }\n\n  async deleteFile(fullPath) {\n    if (!(await this.isAdmin())) {\n      throw new Error('Permission denied: Admin access required');\n    }\n\n    const { error } = await supabase.storage\n      .from('documents')\n      .remove([fullPath]);\n\n    if (error) throw error;\n\n    // Eliminar metadatos en tabla 'archivos' si existe\n    try {\n      await supabase.from('archivos').delete().eq('ruta', fullPath);\n    } catch (e) {\n      console.warn('No se pudo eliminar metadatos de tabla \"archivos\" (puede no existir):', e?.message);\n    }\n  }\n\n  async listFiles(path = '') {\n    const { data, error } = await supabase.storage\n      .from('documents')\n      .list(path, { limit: 100, sortBy: { column: 'name', order: 'asc' } });\n\n    if (error) throw error;\n\n    // Filter files and folders (folders end with /)\n    let files = data.filter(item => !item.name.endsWith('/'));\n    const folders = data\n      .filter(item => item.name.endsWith('/'))\n      .map(item => item.name.slice(0, -1)); // Remove trailing /\n  \n    // Filter out placeholder files\n    files = files.filter(item => item.name !== '_placeholder');\n\n    return { files, folders };\n  }\n\n  async deleteFolder(path) {\n    if (!(await this.isAdmin())) {\n      throw new Error('Permission denied: Admin access required');\n    }\n\n    // Get all contents recursively\n    const { data: items, error: listError } = await supabase.storage\n      .from('documents')\n      .list(path, { recursive: true });\n\n    if (listError) throw listError;\n\n    if (items.length === 0) return; // Empty folder\n\n    // Build full paths to delete\n    const pathsToDelete = items.map(item => `${path}/${item.name}`);\n\n    const { error } = await supabase.storage\n      .from('documents')\n      .remove(pathsToDelete);\n\n    if (error) throw error;\n  }\n\n  async createFolder(folderName, parentPath = '') {\n    if (!(await this.isAdmin())) {\n      throw new Error('Permission denied: Admin access required');\n    }\n\n    const fullPath = parentPath ? `${parentPath}/${folderName}` : folderName;\n    // Create folder by uploading a hidden placeholder file\n    const emptyBlob = new Blob([''], { type: 'application/json' });\n    const { data, error } = await supabase.storage\n      .from('documents')\n      .upload(`${fullPath}/_placeholder`, emptyBlob);\n\n    if (error) throw error;\n    return data;\n  }\n\n  async renameFolder(oldName, newName, parentPath = '') {\n    if (!(await this.isAdmin())) {\n      throw new Error('Permission denied: Admin access required');\n    }\n\n    const oldPath = parentPath ? `${parentPath}/${oldName}` : oldName;\n    const newPath = parentPath ? `${parentPath}/${newName}` : newName;\n\n    // List contents recursively\n    const { data: items, error: listError } = await supabase.storage\n      .from('documents')\n      .list(oldPath, { recursive: true });\n\n    if (listError) throw listError;\n\n    // Move each item\n    for (const item of items) {\n      const oldFullPath = `${oldPath}/${item.name}`;\n      const newFullPath = oldFullPath.replace(oldPath, newPath);\n\n      const { error: moveError } = await supabase.storage\n        .from('documents')\n        .move(oldFullPath, newFullPath);\n\n      if (moveError) {\n        // Rollback on error (simplified; in production, use transactions)\n        console.error('Rename failed for item:', item.name, moveError);\n        throw moveError;\n      }\n    }\n\n    // Delete placeholder if exists\n    await this.deleteFile(`${oldPath}/_placeholder`).catch(() => {}); // Ignore if not exists\n  }\n\n  async getDownloadUrl(path) {\n    const { data, error } = await supabase.storage\n      .from('documents')\n      .getPublicUrl(path);\n\n    if (error) throw error;\n    return data.publicUrl;\n  }\n}\n\nexport const storageService = new StorageService();\nexport default storageService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}