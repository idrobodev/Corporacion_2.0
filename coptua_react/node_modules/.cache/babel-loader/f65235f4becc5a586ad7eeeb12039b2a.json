{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n// @ts-ignore\nimport nodeFetch, { Headers as NodeFetchHeaders } from '@supabase/node-fetch';\nexport const resolveFetch = customFetch => {\n  let _fetch;\n  if (customFetch) {\n    _fetch = customFetch;\n  } else if (typeof fetch === 'undefined') {\n    _fetch = nodeFetch;\n  } else {\n    _fetch = fetch;\n  }\n  return (...args) => _fetch(...args);\n};\nexport const resolveHeadersConstructor = () => {\n  if (typeof Headers === 'undefined') {\n    return NodeFetchHeaders;\n  }\n  return Headers;\n};\nexport const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {\n  const fetch = resolveFetch(customFetch);\n  const HeadersConstructor = resolveHeadersConstructor();\n  return (input, init) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n    const accessToken = (_a = yield getAccessToken()) !== null && _a !== void 0 ? _a : supabaseKey;\n    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n    if (!headers.has('apikey')) {\n      headers.set('apikey', supabaseKey);\n    }\n    if (!headers.has('Authorization')) {\n      headers.set('Authorization', `Bearer ${accessToken}`);\n    }\n    return fetch(input, Object.assign(Object.assign({}, init), {\n      headers\n    }));\n  });\n};","map":{"version":3,"sources":["../../../src/lib/fetch.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA,OAAO,SAAS,IAAI,OAAO,IAAI,gBAAgB,QAAQ,sBAAsB;AAI7E,OAAO,MAAM,YAAY,GAAI,WAAmB,IAAW;EACzD,IAAI,MAAa;EACjB,IAAI,WAAW,EAAE;IACf,MAAM,GAAG,WAAW;GACrB,MAAM,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;IACvC,MAAM,GAAG,SAA6B;GACvC,MAAM;IACL,MAAM,GAAG,KAAK;EACf;EACD,OAAO,CAAC,GAAG,IAAuB,KAAK,MAAM,CAAC,GAAG,IAAI,CAAC;AACxD,CAAC;AAED,OAAO,MAAM,yBAAyB,GAAG,CAAA,KAAK;EAC5C,IAAI,OAAO,OAAO,KAAK,WAAW,EAAE;IAClC,OAAO,gBAAgB;EACxB;EAED,OAAO,OAAO;AAChB,CAAC;AAED,OAAO,MAAM,aAAa,GAAG,CAC3B,WAAmB,EACnB,cAA4C,EAC5C,WAAmB,KACV;EACT,MAAM,KAAK,GAAG,YAAY,CAAC,WAAW,CAAC;EACvC,MAAM,kBAAkB,GAAG,yBAAyB,CAAA,CAAE;EAEtD,OAAO,CAAO,KAAK,EAAE,IAAI,KAAI,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;;IAC3B,MAAM,WAAW,GAAG,CAAA,EAAA,GAAC,MAAM,cAAc,CAAA,CAAG,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,WAAW;IAC3D,IAAI,OAAO,GAAG,IAAI,kBAAkB,CAAC,IAAI,KAAA,IAAA,IAAJ,IAAI,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAJ,IAAI,CAAE,OAAO,CAAC;IAEnD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;MAC1B,OAAO,CAAC,GAAG,CAAC,QAAQ,EAAE,WAAW,CAAC;IACnC;IAED,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,EAAE;MACjC,OAAO,CAAC,GAAG,CAAC,eAAe,EAAE,UAAU,WAAW,EAAE,CAAC;IACtD;IAED,OAAO,KAAK,CAAC,KAAK,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,CAAA,CAAA,EAAO,IAAI,CAAA,EAAA;MAAE;IAAO,CAAA,CAAA,CAAG;EAC3C,CAAC,CAAA;AACH,CAAC","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// @ts-ignore\nimport nodeFetch, { Headers as NodeFetchHeaders } from '@supabase/node-fetch';\nexport const resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = nodeFetch;\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nexport const resolveHeadersConstructor = () => {\n    if (typeof Headers === 'undefined') {\n        return NodeFetchHeaders;\n    }\n    return Headers;\n};\nexport const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {\n    const fetch = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return (input, init) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        const accessToken = (_a = (yield getAccessToken())) !== null && _a !== void 0 ? _a : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has('apikey')) {\n            headers.set('apikey', supabaseKey);\n        }\n        if (!headers.has('Authorization')) {\n            headers.set('Authorization', `Bearer ${accessToken}`);\n        }\n        return fetch(input, Object.assign(Object.assign({}, init), { headers }));\n    });\n};\n//# sourceMappingURL=fetch.js.map"]},"metadata":{},"sourceType":"module"}