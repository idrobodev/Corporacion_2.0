{"ast":null,"code":"import { supportsLocalStorage } from './helpers';\n/**\n * @experimental\n */\nexport const internals = {\n  /**\n   * @experimental\n   */\n  debug: !!(globalThis && supportsLocalStorage() && globalThis.localStorage && globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true')\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nexport class LockAcquireTimeoutError extends Error {\n  constructor(message) {\n    super(message);\n    this.isAcquireTimeout = true;\n  }\n}\nexport class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {}\nexport class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function navigatorLock(name, acquireTimeout, fn) {\n  if (internals.debug) {\n    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n  }\n  const abortController = new globalThis.AbortController();\n  if (acquireTimeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n      if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n      }\n    }, acquireTimeout);\n  }\n  // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n  // Wrapping navigator.locks.request() with a plain Promise is done as some\n  // libraries like zone.js patch the Promise object to track the execution\n  // context. However, it appears that most browsers use an internal promise\n  // implementation when using the navigator.locks.request() API causing them\n  // to lose context and emit confusing log messages or break certain features.\n  // This wrapping is believed to help zone.js track the execution context\n  // better.\n  return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n    mode: 'exclusive',\n    ifAvailable: true\n  } : {\n    mode: 'exclusive',\n    signal: abortController.signal\n  }, async lock => {\n    if (lock) {\n      if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n      }\n      try {\n        return await fn();\n      } finally {\n        if (internals.debug) {\n          console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n        }\n      }\n    } else {\n      if (acquireTimeout === 0) {\n        if (internals.debug) {\n          console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n        }\n        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n      } else {\n        if (internals.debug) {\n          try {\n            const result = await globalThis.navigator.locks.query();\n            console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n          } catch (e) {\n            console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n          }\n        }\n        // Browser is not following the Navigator LockManager spec, it\n        // returned a null lock when we didn't use ifAvailable. So we can\n        // pretend the lock is acquired in the name of backward compatibility\n        // and user experience and just run the function.\n        console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n        return await fn();\n      }\n    }\n  }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function processLock(name, acquireTimeout, fn) {\n  var _a;\n  const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n  const currentOperation = Promise.race([previousOperation.catch(() => {\n    // ignore error of previous operation that we're waiting to finish\n    return null;\n  }), acquireTimeout >= 0 ? new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n    }, acquireTimeout);\n  }) : null].filter(x => x)).catch(e => {\n    if (e && e.isAcquireTimeout) {\n      throw e;\n    }\n    return null;\n  }).then(async () => {\n    // previous operations finished and we didn't get a race on the acquire\n    // timeout, so the current operation can finally start\n    return await fn();\n  });\n  PROCESS_LOCKS[name] = currentOperation.catch(async e => {\n    if (e && e.isAcquireTimeout) {\n      // if the current operation timed out, it doesn't mean that the previous\n      // operation finished, so we need contnue waiting for it to finish\n      await previousOperation;\n      return null;\n    }\n    throw e;\n  });\n  // finally wait for the current operation to finish successfully, with an\n  // error or with an acquire timeout error\n  return await currentOperation;\n}","map":{"version":3,"sources":["../../../src/lib/locks.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { supportsLocalStorage } from './helpers';\n/**\n * @experimental\n */\nexport const internals = {\n    /**\n     * @experimental\n     */\n    debug: !!(globalThis &&\n        supportsLocalStorage() &&\n        globalThis.localStorage &&\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nexport class LockAcquireTimeoutError extends Error {\n    constructor(message) {\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nexport class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nexport class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function navigatorLock(name, acquireTimeout, fn) {\n    if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n            if (internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0\n        ? {\n            mode: 'exclusive',\n            ifAvailable: true,\n        }\n        : {\n            mode: 'exclusive',\n            signal: abortController.signal,\n        }, async (lock) => {\n        if (lock) {\n            if (internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n            }\n            try {\n                return await fn();\n            }\n            finally {\n                if (internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n                }\n            }\n        }\n        else {\n            if (acquireTimeout === 0) {\n                if (internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n                }\n                throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n            }\n            else {\n                if (internals.debug) {\n                    try {\n                        const result = await globalThis.navigator.locks.query();\n                        console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n                    }\n                    catch (e) {\n                        console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n                    }\n                }\n                // Browser is not following the Navigator LockManager spec, it\n                // returned a null lock when we didn't use ifAvailable. So we can\n                // pretend the lock is acquired in the name of backward compatibility\n                // and user experience and just run the function.\n                console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n                return await fn();\n            }\n        }\n    }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(() => {\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0\n            ? new Promise((_, reject) => {\n                setTimeout(() => {\n                    reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n                }, acquireTimeout);\n            })\n            : null,\n    ].filter((x) => x))\n        .catch((e) => {\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    })\n        .then(async () => {\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e) => {\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n}\n//# sourceMappingURL=locks.js.map"]},"metadata":{},"sourceType":"module"}