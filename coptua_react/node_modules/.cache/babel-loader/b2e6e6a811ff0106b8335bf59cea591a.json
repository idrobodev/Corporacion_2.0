{"ast":null,"code":"/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('');\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */\nconst FROM_BASE64URL = (() => {\n  const charMap = new Array(128);\n  for (let i = 0; i < charMap.length; i += 1) {\n    charMap[i] = -1;\n  }\n  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n  }\n  for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n    charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n  }\n  return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */\nexport function byteToBase64URL(byte, state, emit) {\n  if (byte !== null) {\n    state.queue = state.queue << 8 | byte;\n    state.queuedBits += 8;\n    while (state.queuedBits >= 6) {\n      const pos = state.queue >> state.queuedBits - 6 & 63;\n      emit(TO_BASE64URL[pos]);\n      state.queuedBits -= 6;\n    }\n  } else if (state.queuedBits > 0) {\n    state.queue = state.queue << 6 - state.queuedBits;\n    state.queuedBits = 6;\n    while (state.queuedBits >= 6) {\n      const pos = state.queue >> state.queuedBits - 6 & 63;\n      emit(TO_BASE64URL[pos]);\n      state.queuedBits -= 6;\n    }\n  }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */\nexport function byteFromBase64URL(charCode, state, emit) {\n  const bits = FROM_BASE64URL[charCode];\n  if (bits > -1) {\n    // valid Base64-URL character\n    state.queue = state.queue << 6 | bits;\n    state.queuedBits += 6;\n    while (state.queuedBits >= 8) {\n      emit(state.queue >> state.queuedBits - 8 & 0xff);\n      state.queuedBits -= 8;\n    }\n  } else if (bits === -2) {\n    // ignore spaces, tabs, newlines, =\n    return;\n  } else {\n    throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n  }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */\nexport function stringToBase64URL(str) {\n  const base64 = [];\n  const emitter = char => {\n    base64.push(char);\n  };\n  const state = {\n    queue: 0,\n    queuedBits: 0\n  };\n  stringToUTF8(str, byte => {\n    byteToBase64URL(byte, state, emitter);\n  });\n  byteToBase64URL(null, state, emitter);\n  return base64.join('');\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */\nexport function stringFromBase64URL(str) {\n  const conv = [];\n  const utf8Emit = codepoint => {\n    conv.push(String.fromCodePoint(codepoint));\n  };\n  const utf8State = {\n    utf8seq: 0,\n    codepoint: 0\n  };\n  const b64State = {\n    queue: 0,\n    queuedBits: 0\n  };\n  const byteEmit = byte => {\n    stringFromUTF8(byte, utf8State, utf8Emit);\n  };\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n  }\n  return conv.join('');\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */\nexport function codepointToUTF8(codepoint, emit) {\n  if (codepoint <= 0x7f) {\n    emit(codepoint);\n    return;\n  } else if (codepoint <= 0x7ff) {\n    emit(0xc0 | codepoint >> 6);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  } else if (codepoint <= 0xffff) {\n    emit(0xe0 | codepoint >> 12);\n    emit(0x80 | codepoint >> 6 & 0x3f);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  } else if (codepoint <= 0x10ffff) {\n    emit(0xf0 | codepoint >> 18);\n    emit(0x80 | codepoint >> 12 & 0x3f);\n    emit(0x80 | codepoint >> 6 & 0x3f);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  }\n  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */\nexport function stringToUTF8(str, emit) {\n  for (let i = 0; i < str.length; i += 1) {\n    let codepoint = str.charCodeAt(i);\n    if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n      // most UTF-16 codepoints are Unicode codepoints, except values in this\n      // range where the next UTF-16 codepoint needs to be combined with the\n      // current one to get the Unicode codepoint\n      const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n      const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n      codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n      i += 1;\n    }\n    codepointToUTF8(codepoint, emit);\n  }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */\nexport function stringFromUTF8(byte, state, emit) {\n  if (state.utf8seq === 0) {\n    if (byte <= 0x7f) {\n      emit(byte);\n      return;\n    }\n    // count the number of 1 leading bits until you reach 0\n    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n      if ((byte >> 7 - leadingBit & 1) === 0) {\n        state.utf8seq = leadingBit;\n        break;\n      }\n    }\n    if (state.utf8seq === 2) {\n      state.codepoint = byte & 31;\n    } else if (state.utf8seq === 3) {\n      state.codepoint = byte & 15;\n    } else if (state.utf8seq === 4) {\n      state.codepoint = byte & 7;\n    } else {\n      throw new Error('Invalid UTF-8 sequence');\n    }\n    state.utf8seq -= 1;\n  } else if (state.utf8seq > 0) {\n    if (byte <= 0x7f) {\n      throw new Error('Invalid UTF-8 sequence');\n    }\n    state.codepoint = state.codepoint << 6 | byte & 63;\n    state.utf8seq -= 1;\n    if (state.utf8seq === 0) {\n      emit(state.codepoint);\n    }\n  }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */\nexport function base64UrlToUint8Array(str) {\n  const result = [];\n  const state = {\n    queue: 0,\n    queuedBits: 0\n  };\n  const onByte = byte => {\n    result.push(byte);\n  };\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), state, onByte);\n  }\n  return new Uint8Array(result);\n}\nexport function stringToUint8Array(str) {\n  const result = [];\n  stringToUTF8(str, byte => result.push(byte));\n  return new Uint8Array(result);\n}\nexport function bytesToBase64URL(bytes) {\n  const result = [];\n  const state = {\n    queue: 0,\n    queuedBits: 0\n  };\n  const onChar = char => {\n    result.push(char);\n  };\n  bytes.forEach(byte => byteToBase64URL(byte, state, onChar));\n  // always call with `null` after processing all bytes\n  byteToBase64URL(null, state, onChar);\n  return result.join('');\n}","map":{"version":3,"sources":["../../../src/lib/base64url.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('');\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */\nconst FROM_BASE64URL = (() => {\n    const charMap = new Array(128);\n    for (let i = 0; i < charMap.length; i += 1) {\n        charMap[i] = -1;\n    }\n    for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */\nexport function byteToBase64URL(byte, state, emit) {\n    if (byte !== null) {\n        state.queue = (state.queue << 8) | byte;\n        state.queuedBits += 8;\n        while (state.queuedBits >= 6) {\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n    else if (state.queuedBits > 0) {\n        state.queue = state.queue << (6 - state.queuedBits);\n        state.queuedBits = 6;\n        while (state.queuedBits >= 6) {\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */\nexport function byteFromBase64URL(charCode, state, emit) {\n    const bits = FROM_BASE64URL[charCode];\n    if (bits > -1) {\n        // valid Base64-URL character\n        state.queue = (state.queue << 6) | bits;\n        state.queuedBits += 6;\n        while (state.queuedBits >= 8) {\n            emit((state.queue >> (state.queuedBits - 8)) & 0xff);\n            state.queuedBits -= 8;\n        }\n    }\n    else if (bits === -2) {\n        // ignore spaces, tabs, newlines, =\n        return;\n    }\n    else {\n        throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n    }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */\nexport function stringToBase64URL(str) {\n    const base64 = [];\n    const emitter = (char) => {\n        base64.push(char);\n    };\n    const state = { queue: 0, queuedBits: 0 };\n    stringToUTF8(str, (byte) => {\n        byteToBase64URL(byte, state, emitter);\n    });\n    byteToBase64URL(null, state, emitter);\n    return base64.join('');\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */\nexport function stringFromBase64URL(str) {\n    const conv = [];\n    const utf8Emit = (codepoint) => {\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const utf8State = {\n        utf8seq: 0,\n        codepoint: 0,\n    };\n    const b64State = { queue: 0, queuedBits: 0 };\n    const byteEmit = (byte) => {\n        stringFromUTF8(byte, utf8State, utf8Emit);\n    };\n    for (let i = 0; i < str.length; i += 1) {\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n    }\n    return conv.join('');\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */\nexport function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    }\n    else if (codepoint <= 0x7ff) {\n        emit(0xc0 | (codepoint >> 6));\n        emit(0x80 | (codepoint & 0x3f));\n        return;\n    }\n    else if (codepoint <= 0xffff) {\n        emit(0xe0 | (codepoint >> 12));\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\n        emit(0x80 | (codepoint & 0x3f));\n        return;\n    }\n    else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | (codepoint >> 18));\n        emit(0x80 | ((codepoint >> 12) & 0x3f));\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\n        emit(0x80 | (codepoint & 0x3f));\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */\nexport function stringToUTF8(str, emit) {\n    for (let i = 0; i < str.length; i += 1) {\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff;\n            const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */\nexport function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n            if (((byte >> (7 - leadingBit)) & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        }\n        else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        }\n        else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        }\n        else {\n            throw new Error('Invalid UTF-8 sequence');\n        }\n        state.utf8seq -= 1;\n    }\n    else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error('Invalid UTF-8 sequence');\n        }\n        state.codepoint = (state.codepoint << 6) | (byte & 63);\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */\nexport function base64UrlToUint8Array(str) {\n    const result = [];\n    const state = { queue: 0, queuedBits: 0 };\n    const onByte = (byte) => {\n        result.push(byte);\n    };\n    for (let i = 0; i < str.length; i += 1) {\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\n    }\n    return new Uint8Array(result);\n}\nexport function stringToUint8Array(str) {\n    const result = [];\n    stringToUTF8(str, (byte) => result.push(byte));\n    return new Uint8Array(result);\n}\nexport function bytesToBase64URL(bytes) {\n    const result = [];\n    const state = { queue: 0, queuedBits: 0 };\n    const onChar = (char) => {\n        result.push(char);\n    };\n    bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));\n    // always call with `null` after processing all bytes\n    byteToBase64URL(null, state, onChar);\n    return result.join('');\n}\n//# sourceMappingURL=base64url.js.map"]},"metadata":{},"sourceType":"module"}