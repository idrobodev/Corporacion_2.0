{"ast":null,"code":"import { CHANNEL_EVENTS, CHANNEL_STATES, MAX_PUSH_BUFFER_SIZE } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nimport { httpEndpointURL } from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n  REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n  REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n  REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n  REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n  REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n  REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n  REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n  REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n  constructor(/** Topic name can be any string. */\n  topic, params = {\n    config: {}\n  }, socket) {\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = {};\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.subTopic = topic.replace(/^realtime:/i, '');\n    this.params.config = Object.assign({\n      broadcast: {\n        ack: false,\n        self: false\n      },\n      presence: {\n        key: '',\n        enabled: false\n      },\n      private: false\n    }, params.config);\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined;\n      this.rejoinTimer.reset();\n      this.pushBuffer.forEach(pushEvent => pushEvent.send());\n      this.pushBuffer = [];\n    });\n    this._onClose(() => {\n      this.rejoinTimer.reset();\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n      this.state = CHANNEL_STATES.closed;\n      this.socket._remove(this);\n    });\n    this._onError(reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return;\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('error', reason => {\n      if (this._isLeaving() || this._isClosed()) {\n        return;\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason);\n      this.state = CHANNEL_STATES.errored;\n      this.rejoinTimer.scheduleTimeout();\n    });\n    this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n      this._trigger(this._replyEventName(ref), payload);\n    });\n    this.presence = new RealtimePresence(this);\n    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);\n    this.private = this.params.config.private || false;\n  }\n  /** Subscribe registers your client with the server */\n  subscribe(callback, timeout = this.timeout) {\n    var _a, _b, _c;\n    if (!this.socket.isConnected()) {\n      this.socket.connect();\n    }\n    if (this.state == CHANNEL_STATES.closed) {\n      const {\n        config: {\n          broadcast,\n          presence,\n          private: isPrivate\n        }\n      } = this.params;\n      const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : [];\n      const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n      const accessTokenPayload = {};\n      const config = {\n        broadcast,\n        presence: Object.assign(Object.assign({}, presence), {\n          enabled: presence_enabled\n        }),\n        postgres_changes,\n        private: isPrivate\n      };\n      if (this.socket.accessTokenValue) {\n        accessTokenPayload.access_token = this.socket.accessTokenValue;\n      }\n      this._onError(e => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n      this.updateJoinPayload(Object.assign({\n        config\n      }, accessTokenPayload));\n      this.joinedOnce = true;\n      this._rejoin(timeout);\n      this.joinPush.receive('ok', async ({\n        postgres_changes\n      }) => {\n        var _a;\n        this.socket.setAuth();\n        if (postgres_changes === undefined) {\n          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n          return;\n        } else {\n          const clientPostgresBindings = this.bindings.postgres_changes;\n          const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n          const newPostgresBindings = [];\n          for (let i = 0; i < bindingsLen; i++) {\n            const clientPostgresBinding = clientPostgresBindings[i];\n            const {\n              filter: {\n                event,\n                schema,\n                table,\n                filter\n              }\n            } = clientPostgresBinding;\n            const serverPostgresFilter = postgres_changes && postgres_changes[i];\n            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                id: serverPostgresFilter.id\n              }));\n            } else {\n              this.unsubscribe();\n              this.state = CHANNEL_STATES.errored;\n              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\n              return;\n            }\n          }\n          this.bindings.postgres_changes = newPostgresBindings;\n          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n          return;\n        }\n      }).receive('error', error => {\n        this.state = CHANNEL_STATES.errored;\n        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n        return;\n      }).receive('timeout', () => {\n        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n        return;\n      });\n    }\n    return this;\n  }\n  presenceState() {\n    return this.presence.state;\n  }\n  async track(payload, opts = {}) {\n    return await this.send({\n      type: 'presence',\n      event: 'track',\n      payload\n    }, opts.timeout || this.timeout);\n  }\n  async untrack(opts = {}) {\n    return await this.send({\n      type: 'presence',\n      event: 'untrack'\n    }, opts);\n  }\n  on(type, filter, callback) {\n    if (this.state === CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\n      this.socket.log('channel', `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n      this.unsubscribe().then(() => this.subscribe());\n    }\n    return this._on(type, filter, callback);\n  }\n  /**\n   * Sends a message into the channel.\n   *\n   * @param args Arguments to send to channel\n   * @param args.type The type of event to send\n   * @param args.event The name of the event being sent\n   * @param args.payload Payload to be sent\n   * @param opts Options to be used during the send process\n   */\n  async send(args, opts = {}) {\n    var _a, _b;\n    if (!this._canPush() && args.type === 'broadcast') {\n      const {\n        event,\n        payload: endpoint_payload\n      } = args;\n      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : '';\n      const options = {\n        method: 'POST',\n        headers: {\n          Authorization: authorization,\n          apikey: this.socket.apiKey ? this.socket.apiKey : '',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          messages: [{\n            topic: this.subTopic,\n            event,\n            payload: endpoint_payload,\n            private: this.private\n          }]\n        })\n      };\n      try {\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n        return response.ok ? 'ok' : 'error';\n      } catch (error) {\n        if (error.name === 'AbortError') {\n          return 'timed out';\n        } else {\n          return 'error';\n        }\n      }\n    } else {\n      return new Promise(resolve => {\n        var _a, _b, _c;\n        const push = this._push(args.type, args, opts.timeout || this.timeout);\n        if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n          resolve('ok');\n        }\n        push.receive('ok', () => resolve('ok'));\n        push.receive('error', () => resolve('error'));\n        push.receive('timeout', () => resolve('timed out'));\n      });\n    }\n  }\n  updateJoinPayload(payload) {\n    this.joinPush.updatePayload(payload);\n  }\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving;\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`);\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n    };\n    this.joinPush.destroy();\n    let leavePush = null;\n    return new Promise(resolve => {\n      leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', () => {\n        onClose();\n        resolve('ok');\n      }).receive('timeout', () => {\n        onClose();\n        resolve('timed out');\n      }).receive('error', () => {\n        resolve('error');\n      });\n      leavePush.send();\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {});\n      }\n    }).finally(() => {\n      leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n    });\n  }\n  /**\n   * Teardown the channel.\n   *\n   * Destroys and stops related timers.\n   */\n  teardown() {\n    this.pushBuffer.forEach(push => push.destroy());\n    this.pushBuffer = [];\n    this.rejoinTimer.reset();\n    this.joinPush.destroy();\n    this.state = CHANNEL_STATES.closed;\n    this.bindings = {};\n  }\n  /** @internal */\n  async _fetchWithTimeout(url, options, timeout) {\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeout);\n    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n      signal: controller.signal\n    }));\n    clearTimeout(id);\n    return response;\n  }\n  /** @internal */\n  _push(event, payload, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n    }\n    let pushEvent = new Push(this, event, payload, timeout);\n    if (this._canPush()) {\n      pushEvent.send();\n    } else {\n      this._addToPushBuffer(pushEvent);\n    }\n    return pushEvent;\n  }\n  /** @internal */\n  _addToPushBuffer(pushEvent) {\n    pushEvent.startTimeout();\n    this.pushBuffer.push(pushEvent);\n    // Enforce buffer size limit\n    if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {\n      const removedPush = this.pushBuffer.shift();\n      if (removedPush) {\n        removedPush.destroy();\n        this.socket.log('channel', `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n      }\n    }\n  }\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event, payload, _ref) {\n    return payload;\n  }\n  /** @internal */\n  _isMember(topic) {\n    return this.topic === topic;\n  }\n  /** @internal */\n  _joinRef() {\n    return this.joinPush.ref;\n  }\n  /** @internal */\n  _trigger(type, payload, ref) {\n    var _a, _b;\n    const typeLower = type.toLocaleLowerCase();\n    const {\n      close,\n      error,\n      leave,\n      join\n    } = CHANNEL_EVENTS;\n    const events = [close, error, leave, join];\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return;\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref);\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n    }\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {\n        var _a, _b, _c;\n        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n      }).map(bind => bind.callback(handledPayload, ref));\n    } else {\n      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {\n        var _a, _b, _c, _d, _e, _f;\n        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n          if ('id' in bind) {\n            const bindId = bind.id;\n            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n          } else {\n            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n            return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n          }\n        } else {\n          return bind.type.toLocaleLowerCase() === typeLower;\n        }\n      }).map(bind => {\n        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n          const postgresChanges = handledPayload.data;\n          const {\n            schema,\n            table,\n            commit_timestamp,\n            type,\n            errors\n          } = postgresChanges;\n          const enrichedPayload = {\n            schema: schema,\n            table: table,\n            commit_timestamp: commit_timestamp,\n            eventType: type,\n            new: {},\n            old: {},\n            errors: errors\n          };\n          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n        }\n        bind.callback(handledPayload, ref);\n      });\n    }\n  }\n  /** @internal */\n  _isClosed() {\n    return this.state === CHANNEL_STATES.closed;\n  }\n  /** @internal */\n  _isJoined() {\n    return this.state === CHANNEL_STATES.joined;\n  }\n  /** @internal */\n  _isJoining() {\n    return this.state === CHANNEL_STATES.joining;\n  }\n  /** @internal */\n  _isLeaving() {\n    return this.state === CHANNEL_STATES.leaving;\n  }\n  /** @internal */\n  _replyEventName(ref) {\n    return `chan_reply_${ref}`;\n  }\n  /** @internal */\n  _on(type, filter, callback) {\n    const typeLower = type.toLocaleLowerCase();\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback\n    };\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding);\n    } else {\n      this.bindings[typeLower] = [binding];\n    }\n    return this;\n  }\n  /** @internal */\n  _off(type, filter) {\n    const typeLower = type.toLocaleLowerCase();\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {\n        var _a;\n        return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n      });\n    }\n    return this;\n  }\n  /** @internal */\n  static isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false;\n    }\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /** @internal */\n  _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout();\n    if (this.socket.isConnected()) {\n      this._rejoin();\n    }\n  }\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  _onClose(callback) {\n    this._on(CHANNEL_EVENTS.close, {}, callback);\n  }\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  _onError(callback) {\n    this._on(CHANNEL_EVENTS.error, {}, reason => callback(reason));\n  }\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  _canPush() {\n    return this.socket.isConnected() && this._isJoined();\n  }\n  /** @internal */\n  _rejoin(timeout = this.timeout) {\n    if (this._isLeaving()) {\n      return;\n    }\n    this.socket._leaveOpenTopic(this.topic);\n    this.state = CHANNEL_STATES.joining;\n    this.joinPush.resend(timeout);\n  }\n  /** @internal */\n  _getPayloadRecords(payload) {\n    const records = {\n      new: {},\n      old: {}\n    };\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record);\n    }\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n    }\n    return records;\n  }\n}","map":{"version":3,"sources":["../../src/RealtimeChannel.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES, MAX_PUSH_BUFFER_SIZE, } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nimport { httpEndpointURL } from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n    constructor(\n    /** Topic name can be any string. */\n    topic, params = { config: {} }, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, '');\n        this.params.config = Object.assign({\n            broadcast: { ack: false, self: false },\n            presence: { key: '', enabled: false },\n            private: false,\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n            this.state = CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('error', (reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new RealtimePresence(this);\n        this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint);\n        this.private = this.params.config.private || false;\n    }\n    /** Subscribe registers your client with the server */\n    subscribe(callback, timeout = this.timeout) {\n        var _a, _b, _c;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.state == CHANNEL_STATES.closed) {\n            const { config: { broadcast, presence, private: isPrivate }, } = this.params;\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [];\n            const presence_enabled = (!!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] &&\n                this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0) ||\n                ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),\n                postgres_changes,\n                private: isPrivate,\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush\n                .receive('ok', async ({ postgres_changes }) => {\n                var _a;\n                this.socket.setAuth();\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n                else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for (let i = 0; i < bindingsLen; i++) {\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter &&\n                            serverPostgresFilter.event === event &&\n                            serverPostgresFilter.schema === schema &&\n                            serverPostgresFilter.table === table &&\n                            serverPostgresFilter.filter === filter) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n                        }\n                        else {\n                            this.unsubscribe();\n                            this.state = CHANNEL_STATES.errored;\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            })\n                .receive('error', (error) => {\n                this.state = CHANNEL_STATES.errored;\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n                return;\n            })\n                .receive('timeout', () => {\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    presenceState() {\n        return this.presence.state;\n    }\n    async track(payload, opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'track',\n            payload,\n        }, opts.timeout || this.timeout);\n    }\n    async untrack(opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'untrack',\n        }, opts);\n    }\n    on(type, filter, callback) {\n        if (this.state === CHANNEL_STATES.joined &&\n            type === REALTIME_LISTEN_TYPES.PRESENCE) {\n            this.socket.log('channel', `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n            this.unsubscribe().then(() => this.subscribe());\n        }\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */\n    async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === 'broadcast') {\n            const { event, payload: endpoint_payload } = args;\n            const authorization = this.socket.accessTokenValue\n                ? `Bearer ${this.socket.accessTokenValue}`\n                : '';\n            const options = {\n                method: 'POST',\n                headers: {\n                    Authorization: authorization,\n                    apikey: this.socket.apiKey ? this.socket.apiKey : '',\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private,\n                        },\n                    ],\n                }),\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? 'ok' : 'error';\n            }\n            catch (error) {\n                if (error.name === 'AbortError') {\n                    return 'timed out';\n                }\n                else {\n                    return 'error';\n                }\n            }\n        }\n        else {\n            return new Promise((resolve) => {\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve('ok');\n                }\n                push.receive('ok', () => resolve('ok'));\n                push.receive('error', () => resolve('error'));\n                push.receive('timeout', () => resolve('timed out'));\n            });\n        }\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = CHANNEL_STATES.leaving;\n        const onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n        };\n        this.joinPush.destroy();\n        let leavePush = null;\n        return new Promise((resolve) => {\n            leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush\n                .receive('ok', () => {\n                onClose();\n                resolve('ok');\n            })\n                .receive('timeout', () => {\n                onClose();\n                resolve('timed out');\n            })\n                .receive('error', () => {\n                resolve('error');\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger('ok', {});\n            }\n        }).finally(() => {\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n        });\n    }\n    /**\n     * Teardown the channel.\n     *\n     * Destroys and stops related timers.\n     */\n    teardown() {\n        this.pushBuffer.forEach((push) => push.destroy());\n        this.pushBuffer = [];\n        this.rejoinTimer.reset();\n        this.joinPush.destroy();\n        this.state = CHANNEL_STATES.closed;\n        this.bindings = {};\n    }\n    /** @internal */\n    async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(() => controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */\n    _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new Push(this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        }\n        else {\n            this._addToPushBuffer(pushEvent);\n        }\n        return pushEvent;\n    }\n    /** @internal */\n    _addToPushBuffer(pushEvent) {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n        // Enforce buffer size limit\n        if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {\n            const removedPush = this.pushBuffer.shift();\n            if (removedPush) {\n                removedPush.destroy();\n                this.socket.log('channel', `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n            }\n        }\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */\n    _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */\n    _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */\n    _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */\n    _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = CHANNEL_EVENTS;\n        const events = [close, error, leave, join];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n                var _a, _b, _c;\n                return (((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' ||\n                    ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower);\n            }).map((bind) => bind.callback(handledPayload, ref));\n        }\n        else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n                var _a, _b, _c, _d, _e, _f;\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n                    if ('id' in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return (bindId &&\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\n                            (bindEvent === '*' ||\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) ===\n                                    ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\n                    }\n                    else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return (bindEvent === '*' ||\n                            bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase()));\n                    }\n                }\n                else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind) => {\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors,\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */\n    _isClosed() {\n        return this.state === CHANNEL_STATES.closed;\n    }\n    /** @internal */\n    _isJoined() {\n        return this.state === CHANNEL_STATES.joined;\n    }\n    /** @internal */\n    _isJoining() {\n        return this.state === CHANNEL_STATES.joining;\n    }\n    /** @internal */\n    _isLeaving() {\n        return this.state === CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n    _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */\n    _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback,\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        }\n        else {\n            this.bindings[typeLower] = [binding];\n        }\n        return this;\n    }\n    /** @internal */\n    _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n                var _a;\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\n                    RealtimeChannel.isEqual(bind.filter, filter));\n            });\n        }\n        return this;\n    }\n    /** @internal */\n    static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (const k in obj1) {\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */\n    _onClose(callback) {\n        this._on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */\n    _onError(callback) {\n        this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */\n    _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n    _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */\n    _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {},\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n}\n//# sourceMappingURL=RealtimeChannel.js.map"]},"metadata":{},"sourceType":"module"}