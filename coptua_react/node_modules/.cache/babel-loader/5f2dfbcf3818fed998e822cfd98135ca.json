{"ast":null,"code":"/**\n * Helpers to convert the change Payload into native JS types.\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nexport var PostgresTypes;\n(function (PostgresTypes) {\n  PostgresTypes[\"abstime\"] = \"abstime\";\n  PostgresTypes[\"bool\"] = \"bool\";\n  PostgresTypes[\"date\"] = \"date\";\n  PostgresTypes[\"daterange\"] = \"daterange\";\n  PostgresTypes[\"float4\"] = \"float4\";\n  PostgresTypes[\"float8\"] = \"float8\";\n  PostgresTypes[\"int2\"] = \"int2\";\n  PostgresTypes[\"int4\"] = \"int4\";\n  PostgresTypes[\"int4range\"] = \"int4range\";\n  PostgresTypes[\"int8\"] = \"int8\";\n  PostgresTypes[\"int8range\"] = \"int8range\";\n  PostgresTypes[\"json\"] = \"json\";\n  PostgresTypes[\"jsonb\"] = \"jsonb\";\n  PostgresTypes[\"money\"] = \"money\";\n  PostgresTypes[\"numeric\"] = \"numeric\";\n  PostgresTypes[\"oid\"] = \"oid\";\n  PostgresTypes[\"reltime\"] = \"reltime\";\n  PostgresTypes[\"text\"] = \"text\";\n  PostgresTypes[\"time\"] = \"time\";\n  PostgresTypes[\"timestamp\"] = \"timestamp\";\n  PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n  PostgresTypes[\"timetz\"] = \"timetz\";\n  PostgresTypes[\"tsrange\"] = \"tsrange\";\n  PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (columns, record, options = {}) => {\n  var _a;\n  const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n    return acc;\n  }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (columnName, columns, record, skipTypes) => {\n  const column = columns.find(x => x.name === columnName);\n  const colType = column === null || column === void 0 ? void 0 : column.type;\n  const value = record[columnName];\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value);\n  }\n  return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type, value) => {\n  // if data type is an array\n  if (type.charAt(0) === '_') {\n    const dataType = type.slice(1, type.length);\n    return toArray(value, dataType);\n  }\n  // If not null, convert to correct type.\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value);\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value);\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value);\n    case PostgresTypes.timestamp:\n      return toTimestampString(value);\n    // Format to be consistent with PostgREST\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n    case PostgresTypes.text:\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value);\n    default:\n      // Return the value for remaining types\n      return noop(value);\n  }\n};\nconst noop = value => {\n  return value;\n};\nexport const toBoolean = value => {\n  switch (value) {\n    case 't':\n      return true;\n    case 'f':\n      return false;\n    default:\n      return value;\n  }\n};\nexport const toNumber = value => {\n  if (typeof value === 'string') {\n    const parsedValue = parseFloat(value);\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue;\n    }\n  }\n  return value;\n};\nexport const toJson = value => {\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value);\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`);\n      return value;\n    }\n  }\n  return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value, type) => {\n  if (typeof value !== 'string') {\n    return value;\n  }\n  const lastIdx = value.length - 1;\n  const closeBrace = value[lastIdx];\n  const openBrace = value[0];\n  // Confirm value is a Postgres array by checking curly brackets\n  if (openBrace === '{' && closeBrace === '}') {\n    let arr;\n    const valTrim = value.slice(1, lastIdx);\n    // TODO: find a better solution to separate Postgres array data\n    try {\n      arr = JSON.parse('[' + valTrim + ']');\n    } catch (_) {\n      // WARNING: splitting on comma does not cover all edge cases\n      arr = valTrim ? valTrim.split(',') : [];\n    }\n    return arr.map(val => convertCell(type, val));\n  }\n  return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = value => {\n  if (typeof value === 'string') {\n    return value.replace(' ', 'T');\n  }\n  return value;\n};\nexport const httpEndpointURL = socketUrl => {\n  let url = socketUrl;\n  url = url.replace(/^ws/i, 'http');\n  url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\n  return url.replace(/\\/+$/, '') + '/api/broadcast';\n};","map":{"version":3,"sources":["../../../src/lib/transformers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Helpers to convert the change Payload into native JS types.\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nexport var PostgresTypes;\n(function (PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (columns, record, options = {}) => {\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    return Object.keys(record).reduce((acc, rec_key) => {\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (columnName, columns, record, skipTypes) => {\n    const column = columns.find((x) => x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type, value) => {\n    // if data type is an array\n    if (type.charAt(0) === '_') {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch (type) {\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n        case PostgresTypes.date: // To allow users to cast it based on Timezone\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n        case PostgresTypes.text:\n        case PostgresTypes.time: // To allow users to cast it based on Timezone\n        case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n        case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value) => {\n    return value;\n};\nexport const toBoolean = (value) => {\n    switch (value) {\n        case 't':\n            return true;\n        case 'f':\n            return false;\n        default:\n            return value;\n    }\n};\nexport const toNumber = (value) => {\n    if (typeof value === 'string') {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nexport const toJson = (value) => {\n    if (typeof value === 'string') {\n        try {\n            return JSON.parse(value);\n        }\n        catch (error) {\n            console.log(`JSON parse error: ${error}`);\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value, type) => {\n    if (typeof value !== 'string') {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === '{' && closeBrace === '}') {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse('[' + valTrim + ']');\n        }\n        catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(',') : [];\n        }\n        return arr.map((val) => convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (value) => {\n    if (typeof value === 'string') {\n        return value.replace(' ', 'T');\n    }\n    return value;\n};\nexport const httpEndpointURL = (socketUrl) => {\n    let url = socketUrl;\n    url = url.replace(/^ws/i, 'http');\n    url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\n    return url.replace(/\\/+$/, '') + '/api/broadcast';\n};\n//# sourceMappingURL=transformers.js.map"]},"metadata":{},"sourceType":"module"}