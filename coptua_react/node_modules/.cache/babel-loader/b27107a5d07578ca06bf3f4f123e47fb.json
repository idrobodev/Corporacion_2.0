{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst PostgrestBuilder_1 = __importDefault(require(\"./PostgrestBuilder\"));\nclass PostgrestTransformBuilder extends PostgrestBuilder_1.default {\n  /**\n   * Perform a SELECT on the query result.\n   *\n   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n   * return modified rows. By calling this method, modified rows are returned in\n   * `data`.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   */\n  select(columns) {\n    // Remove whitespaces except when quoted\n    let quoted = false;\n    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(c => {\n      if (/\\s/.test(c) && !quoted) {\n        return '';\n      }\n      if (c === '\"') {\n        quoted = !quoted;\n      }\n      return c;\n    }).join('');\n    this.url.searchParams.set('select', cleanedColumns);\n    this.headers.append('Prefer', 'return=representation');\n    return this;\n  }\n  /**\n   * Order the query result by `column`.\n   *\n   * You can call this method multiple times to order by multiple columns.\n   *\n   * You can order referenced tables, but it only affects the ordering of the\n   * parent table if you use `!inner` in the query.\n   *\n   * @param column - The column to order by\n   * @param options - Named parameters\n   * @param options.ascending - If `true`, the result will be in ascending order\n   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n   * `null`s appear last.\n   * @param options.referencedTable - Set this to order a referenced table by\n   * its columns\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  order(column, {\n    ascending = true,\n    nullsFirst,\n    foreignTable,\n    referencedTable = foreignTable\n  } = {}) {\n    const key = referencedTable ? `${referencedTable}.order` : 'order';\n    const existingOrder = this.url.searchParams.get(key);\n    this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'}`);\n    return this;\n  }\n  /**\n   * Limit the query result by `count`.\n   *\n   * @param count - The maximum number of rows to return\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  limit(count, {\n    foreignTable,\n    referencedTable = foreignTable\n  } = {}) {\n    const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;\n    this.url.searchParams.set(key, `${count}`);\n    return this;\n  }\n  /**\n   * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n   * Only records within this range are returned.\n   * This respects the query order and if there is no order clause the range could behave unexpectedly.\n   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n   * and fourth rows of the query.\n   *\n   * @param from - The starting index from which to limit the result\n   * @param to - The last index to which to limit the result\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  range(from, to, {\n    foreignTable,\n    referencedTable = foreignTable\n  } = {}) {\n    const keyOffset = typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`;\n    const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;\n    this.url.searchParams.set(keyOffset, `${from}`);\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n    return this;\n  }\n  /**\n   * Set the AbortSignal for the fetch request.\n   *\n   * @param signal - The AbortSignal to use for the fetch request\n   */\n  abortSignal(signal) {\n    this.signal = signal;\n    return this;\n  }\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n   * returns an error.\n   */\n  single() {\n    this.headers.set('Accept', 'application/vnd.pgrst.object+json');\n    return this;\n  }\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n   * this returns an error.\n   */\n  maybeSingle() {\n    // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n    // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n    if (this.method === 'GET') {\n      this.headers.set('Accept', 'application/json');\n    } else {\n      this.headers.set('Accept', 'application/vnd.pgrst.object+json');\n    }\n    this.isMaybeSingle = true;\n    return this;\n  }\n  /**\n   * Return `data` as a string in CSV format.\n   */\n  csv() {\n    this.headers.set('Accept', 'text/csv');\n    return this;\n  }\n  /**\n   * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n   */\n  geojson() {\n    this.headers.set('Accept', 'application/geo+json');\n    return this;\n  }\n  /**\n   * Return `data` as the EXPLAIN plan for the query.\n   *\n   * You need to enable the\n   * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n   * setting before using this method.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.analyze - If `true`, the query will be executed and the\n   * actual run time will be returned\n   *\n   * @param options.verbose - If `true`, the query identifier will be returned\n   * and `data` will include the output columns of the query\n   *\n   * @param options.settings - If `true`, include information on configuration\n   * parameters that affect query planning\n   *\n   * @param options.buffers - If `true`, include information on buffer usage\n   *\n   * @param options.wal - If `true`, include information on WAL record generation\n   *\n   * @param options.format - The format of the output, can be `\"text\"` (default)\n   * or `\"json\"`\n   */\n  explain({\n    analyze = false,\n    verbose = false,\n    settings = false,\n    buffers = false,\n    wal = false,\n    format = 'text'\n  } = {}) {\n    var _a;\n    const options = [analyze ? 'analyze' : null, verbose ? 'verbose' : null, settings ? 'settings' : null, buffers ? 'buffers' : null, wal ? 'wal' : null].filter(Boolean).join('|');\n    // An Accept header can carry multiple media types but postgrest-js always sends one\n    const forMediatype = (_a = this.headers.get('Accept')) !== null && _a !== void 0 ? _a : 'application/json';\n    this.headers.set('Accept', `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`);\n    if (format === 'json') {\n      return this;\n    } else {\n      return this;\n    }\n  }\n  /**\n   * Rollback the query.\n   *\n   * `data` will still be returned, but the query is not committed.\n   */\n  rollback() {\n    this.headers.append('Prefer', 'tx=rollback');\n    return this;\n  }\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns() {\n    return this;\n  }\n  /**\n   * Set the maximum number of rows that can be affected by the query.\n   * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n   *\n   * @param value - The maximum number of rows that can be affected\n   */\n  maxAffected(value) {\n    this.headers.append('Prefer', 'handling=strict');\n    this.headers.append('Prefer', `max-affected=${value}`);\n    return this;\n  }\n}\nexports.default = PostgrestTransformBuilder;","map":{"version":3,"sources":["../../src/PostgrestTransformBuilder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst PostgrestBuilder_1 = __importDefault(require(\"./PostgrestBuilder\"));\nclass PostgrestTransformBuilder extends PostgrestBuilder_1.default {\n    /**\n     * Perform a SELECT on the query result.\n     *\n     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n     * return modified rows. By calling this method, modified rows are returned in\n     * `data`.\n     *\n     * @param columns - The columns to retrieve, separated by commas\n     */\n    select(columns) {\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*')\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        this.headers.append('Prefer', 'return=representation');\n        return this;\n    }\n    /**\n     * Order the query result by `column`.\n     *\n     * You can call this method multiple times to order by multiple columns.\n     *\n     * You can order referenced tables, but it only affects the ordering of the\n     * parent table if you use `!inner` in the query.\n     *\n     * @param column - The column to order by\n     * @param options - Named parameters\n     * @param options.ascending - If `true`, the result will be in ascending order\n     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n     * `null`s appear last.\n     * @param options.referencedTable - Set this to order a referenced table by\n     * its columns\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */\n    order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable, } = {}) {\n        const key = referencedTable ? `${referencedTable}.order` : 'order';\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'}`);\n        return this;\n    }\n    /**\n     * Limit the query result by `count`.\n     *\n     * @param count - The maximum number of rows to return\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to limit rows of referenced\n     * tables instead of the parent table\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */\n    limit(count, { foreignTable, referencedTable = foreignTable, } = {}) {\n        const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n     * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n     * Only records within this range are returned.\n     * This respects the query order and if there is no order clause the range could behave unexpectedly.\n     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n     * and fourth rows of the query.\n     *\n     * @param from - The starting index from which to limit the result\n     * @param to - The last index to which to limit the result\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to limit rows of referenced\n     * tables instead of the parent table\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */\n    range(from, to, { foreignTable, referencedTable = foreignTable, } = {}) {\n        const keyOffset = typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`;\n        const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        // Range is inclusive, so add 1\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n     * Set the AbortSignal for the fetch request.\n     *\n     * @param signal - The AbortSignal to use for the fetch request\n     */\n    abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n     * returns an error.\n     */\n    single() {\n        this.headers.set('Accept', 'application/vnd.pgrst.object+json');\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n     * this returns an error.\n     */\n    maybeSingle() {\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.method === 'GET') {\n            this.headers.set('Accept', 'application/json');\n        }\n        else {\n            this.headers.set('Accept', 'application/vnd.pgrst.object+json');\n        }\n        this.isMaybeSingle = true;\n        return this;\n    }\n    /**\n     * Return `data` as a string in CSV format.\n     */\n    csv() {\n        this.headers.set('Accept', 'text/csv');\n        return this;\n    }\n    /**\n     * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n     */\n    geojson() {\n        this.headers.set('Accept', 'application/geo+json');\n        return this;\n    }\n    /**\n     * Return `data` as the EXPLAIN plan for the query.\n     *\n     * You need to enable the\n     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n     * setting before using this method.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.analyze - If `true`, the query will be executed and the\n     * actual run time will be returned\n     *\n     * @param options.verbose - If `true`, the query identifier will be returned\n     * and `data` will include the output columns of the query\n     *\n     * @param options.settings - If `true`, include information on configuration\n     * parameters that affect query planning\n     *\n     * @param options.buffers - If `true`, include information on buffer usage\n     *\n     * @param options.wal - If `true`, include information on WAL record generation\n     *\n     * @param options.format - The format of the output, can be `\"text\"` (default)\n     * or `\"json\"`\n     */\n    explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = 'text', } = {}) {\n        var _a;\n        const options = [\n            analyze ? 'analyze' : null,\n            verbose ? 'verbose' : null,\n            settings ? 'settings' : null,\n            buffers ? 'buffers' : null,\n            wal ? 'wal' : null,\n        ]\n            .filter(Boolean)\n            .join('|');\n        // An Accept header can carry multiple media types but postgrest-js always sends one\n        const forMediatype = (_a = this.headers.get('Accept')) !== null && _a !== void 0 ? _a : 'application/json';\n        this.headers.set('Accept', `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`);\n        if (format === 'json') {\n            return this;\n        }\n        else {\n            return this;\n        }\n    }\n    /**\n     * Rollback the query.\n     *\n     * `data` will still be returned, but the query is not committed.\n     */\n    rollback() {\n        this.headers.append('Prefer', 'tx=rollback');\n        return this;\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n     */\n    returns() {\n        return this;\n    }\n    /**\n     * Set the maximum number of rows that can be affected by the query.\n     * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n     *\n     * @param value - The maximum number of rows that can be affected\n     */\n    maxAffected(value) {\n        this.headers.append('Prefer', 'handling=strict');\n        this.headers.append('Prefer', `max-affected=${value}`);\n        return this;\n    }\n}\nexports.default = PostgrestTransformBuilder;\n//# sourceMappingURL=PostgrestTransformBuilder.js.map"]},"metadata":{},"sourceType":"script"}